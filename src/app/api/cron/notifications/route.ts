import { NextRequest, NextResponse } from 'next/server';
import dbConnect from '@/lib/db';
import Notification from '@/models/Notification';
import ChitGroup from '@/models/ChitGroup';
import GroupMember from '@/models/GroupMember';
import { isPushConfigured, sendToMember, sendToGroup, interpolateTemplate } from '@/lib/pushService';
import { sendNotificationToTargets } from '../../notifications/route';
import { calculateCurrentPeriod, calculatePaymentStatus, calculateOverdueAmount } from '@/lib/utils';

// Unified cron endpoint that handles BOTH:
// 1. Sending scheduled (admin-created) notifications whose time has come
// 2. Auto-generating overdue alerts, payment reminders, and group-started notifications
//
// Secured by CRON_SECRET in Authorization header or x-internal-cron header
// Call via: GET /api/cron/notifications (with Bearer token)

const DEDUP_HOURS = 24;

export async function GET(request: NextRequest) {
    const authHeader = request.headers.get('authorization');
    const cronSecret = process.env.CRON_SECRET;
    const isInternal = request.headers.get('x-internal-cron') === 'true';

    // Allow internal calls (from admin page polling) or with correct CRON_SECRET
    if (!isInternal) {
        if (!cronSecret) {
            return NextResponse.json({ error: 'CRON_SECRET not configured' }, { status: 500 });
        }
        const token = authHeader?.replace('Bearer ', '');
        if (token !== cronSecret) {
            return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
        }
    }

    if (!isPushConfigured()) {
        return NextResponse.json({ error: 'Push not configured' }, { status: 500 });
    }

    await dbConnect();

    const results = {
        scheduled: { processed: 0, totalSent: 0, totalFailed: 0 },
        auto: { overdueAlerts: 0, paymentReminders: 0, groupStarted: 0, skippedDuplicates: 0, pushSent: 0, pushFailed: 0 },
    };

    try {
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // PART 1: Process scheduled (admin-created) notifications
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        const now = new Date();
        const dueNotifications = await Notification.find({
            status: 'SCHEDULED',
            scheduledAt: { $lte: now },
        });

        for (const notification of dueNotifications) {
            try {
                const result = await sendNotificationToTargets(notification);
                notification.status = 'SENT';
                notification.successCount = result.sent;
                notification.failCount = result.failed;
                notification.sentAt = new Date();
                await notification.save();

                results.scheduled.processed++;
                results.scheduled.totalSent += result.sent;
                results.scheduled.totalFailed += result.failed;

                console.log(`ðŸ“¤ Scheduled notification sent: "${notification.title}" (${result.sent} delivered, ${result.failed} failed)`);
            } catch (error) {
                console.error(`Failed to send scheduled notification ${notification._id}:`, error);
                notification.status = 'FAILED';
                await notification.save();
            }
        }

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // PART 2: Auto-generate overdue/reminder/group-started
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        const activeGroups = await ChitGroup.find({ status: 'ACTIVE' }).lean();
        const dedupCutoff = new Date(Date.now() - DEDUP_HOURS * 60 * 60 * 1000);

        for (const group of activeGroups) {
            const currentPeriod = calculateCurrentPeriod(group as any);

            // â”€â”€ GROUP_STARTED (one-time) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            if (currentPeriod === 1) {
                const alreadySent = await Notification.findOne({
                    notificationType: 'GROUP_STARTED',
                    targetType: 'GROUP',
                    targetId: group._id,
                    autoGenerated: true,
                });
                if (!alreadySent) {
                    const notif = await Notification.create({
                        title: `${group.groupName} has started!`,
                        body: `Your chit group "${group.groupName}" has officially started. Period 1 is now active.`,
                        url: `/groups/${group._id}`,
                        priority: 'normal',
                        targetType: 'GROUP',
                        targetId: group._id,
                        notificationType: 'GROUP_STARTED',
                        autoGenerated: true,
                        status: 'SENT',
                        sentAt: new Date(),
                    });
                    try {
                        const result = await sendToGroup(group._id!.toString(), {
                            title: notif.title,
                            body: notif.body,
                            url: notif.url,
                            tag: `group-started-${group._id}`,
                        });
                        notif.successCount = result.sent;
                        notif.failCount = result.failed;
                        await notif.save();
                        results.auto.pushSent += result.sent;
                        results.auto.pushFailed += result.failed;
                    } catch (e) {
                        console.error(`Push GROUP_STARTED failed for ${group.groupName}:`, e);
                    }
                    results.auto.groupStarted++;
                }
            }

            if (currentPeriod === 0) continue;

            // â”€â”€ Per-member checks â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            const subscriptions = await GroupMember.find({
                groupId: group._id,
                status: 'ACTIVE',
            }).populate('memberId', 'name phone');

            for (const sub of subscriptions) {
                const member = sub.memberId as any;
                if (!member || !member._id) continue;

                const paymentStatus = calculatePaymentStatus(group as any, sub);
                const overdueAmount = calculateOverdueAmount(group as any, sub);

                // â”€â”€ OVERDUE_ALERT â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
                if (paymentStatus === 'OVERDUE' && overdueAmount > 0) {
                    const alreadySent = await Notification.findOne({
                        notificationType: 'OVERDUE_ALERT',
                        targetType: 'MEMBER',
                        targetId: member._id,
                        autoGenerated: true,
                        url: { $regex: group._id!.toString() },
                        createdAt: { $gte: dedupCutoff },
                    });
                    if (alreadySent) { results.auto.skippedDuplicates++; continue; }

                    const title = 'Payment Overdue';
                    const body = interpolateTemplate(
                        'Hi {{memberName}}, you have an overdue payment of â‚¹{{amount}} for "{{groupName}}" (Period {{period}}). Please pay at the earliest.',
                        { memberName: member.name, amount: overdueAmount.toLocaleString('en-IN'), groupName: group.groupName, period: currentPeriod }
                    );

                    const notif = await Notification.create({
                        title, body, url: `/groups/${group._id}`, priority: 'urgent',
                        targetType: 'MEMBER', targetId: member._id,
                        notificationType: 'OVERDUE_ALERT', autoGenerated: true,
                        status: 'SENT', sentAt: new Date(),
                    });
                    try {
                        const result = await sendToMember(member._id.toString(), {
                            title, body, url: `/groups/${group._id}`, priority: 'urgent',
                            tag: `overdue-${group._id}-${member._id}`,
                        });
                        notif.successCount = result.sent; notif.failCount = result.failed;
                        await notif.save();
                        results.auto.pushSent += result.sent; results.auto.pushFailed += result.failed;
                    } catch (e) { console.error(`Push OVERDUE failed (member ${member._id}):`, e); }
                    results.auto.overdueAlerts++;
                }

                // â”€â”€ PAYMENT_REMINDER (DUE) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
                if (paymentStatus === 'DUE') {
                    const dueAmount = currentPeriod * group.contributionAmount * sub.units - sub.totalCollected;

                    const alreadySent = await Notification.findOne({
                        notificationType: 'PAYMENT_REMINDER',
                        targetType: 'MEMBER',
                        targetId: member._id,
                        autoGenerated: true,
                        url: { $regex: group._id!.toString() },
                        createdAt: { $gte: dedupCutoff },
                    });
                    if (alreadySent) { results.auto.skippedDuplicates++; continue; }

                    const title = 'Payment Reminder';
                    const body = interpolateTemplate(
                        'Hi {{memberName}}, your payment of â‚¹{{amount}} for "{{groupName}}" (Period {{period}}) is due. Please pay on time.',
                        { memberName: member.name, amount: dueAmount.toLocaleString('en-IN'), groupName: group.groupName, period: currentPeriod }
                    );

                    const notif = await Notification.create({
                        title, body, url: `/groups/${group._id}`, priority: 'normal',
                        targetType: 'MEMBER', targetId: member._id,
                        notificationType: 'PAYMENT_REMINDER', autoGenerated: true,
                        status: 'SENT', sentAt: new Date(),
                    });
                    try {
                        const result = await sendToMember(member._id.toString(), {
                            title, body, url: `/groups/${group._id}`,
                            tag: `reminder-${group._id}-${member._id}`,
                        });
                        notif.successCount = result.sent; notif.failCount = result.failed;
                        await notif.save();
                        results.auto.pushSent += result.sent; results.auto.pushFailed += result.failed;
                    } catch (e) { console.error(`Push REMINDER failed (member ${member._id}):`, e); }
                    results.auto.paymentReminders++;
                }
            }
        }

        return NextResponse.json({
            message: 'Cron job complete',
            scheduled: results.scheduled,
            autoNotifications: results.auto,
            timestamp: new Date().toISOString(),
        });
    } catch (error: any) {
        console.error('Cron notification error:', error);
        return NextResponse.json({ error: 'Cron job failed' }, { status: 500 });
    }
}
